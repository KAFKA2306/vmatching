## 目的と原則
- 目的は、設計・要求仕様に沿ったVRChatワールドを「Ubuntu 22.04 + Unity Hub + VCC/SDK3/UdonSharp」の構成で安定的に開発・テストし、Claude Code を主要なコーディングエージェントとして生産性と一貫性を高めることである。[2][1]
- 原則は「単一ワールド内完結」「外部連携なし」「自己データはPlayerDataで永続化」「公開は縮約データのみ」「低負荷で在室者間の即時推薦」に整合するツール選定と手順の標準化である。[1][2]

## ホストOS
- ベースOSは Ubuntu 22.04 LTS とし、Unity Hub を用いて Unity 2022 LTS 系のエディタを管理・切替できる状態を標準とする（Unity 2022 LTS 系は設計上の技術前提である）。[2][1]
- PC/Quest双方を対象とするため、後述のツールチェーンでビルドターゲットを切替可能な構成を前提とする（目標FPSとサイズ要件は設計・要求仕様に準拠）。[1][2]

## ツールチェーン
- Unity Hub（エディタ管理）＋ Unity 2022 LTS 系エディタをインストールし、VCC（VRChat Creator Companion）から SDK3 Worlds と UdonSharp を導入するのを標準フローとする。[2][1]
- プロジェクトは SDK3 Worlds を用い、UdonSharp で実装し、Persistence（PlayerData）を設計通りに使用できるテンプレートをVCCで用意する。[1][2]

## リポジトリ構成
- ルート直下に Unity プロジェクト（Packages/manifest.json をVCC管理に対応）、/Docs に requirement.md・design.md・architecture.md・devenv.md を配置し、設計資産と実装を同居させる。[2][1]
- /Assets 以下に UdonSharp スクリプト群（PlayerDataManager、DiagnosisController、VectorBuilder、PublicProfilePublisher、CompatibilityCalculator、RecommenderUI、SessionRoomManager、ValuesSummaryGenerator、PerfGuard、SafetyController）を論理分割して配置する。[1][2]

## Claude Code の役割
- Claude Code を主エージェントとし、UdonSharp スクリプトの作成・改修・リファクタ・テストコード（可能範囲でのエディタ補助）・設計文書の更新ドラフト生成を行う運用を標準とする。[2][1]
- Claude Code は設計上の制約（SDK3 Worlds、UdonSharp、PlayerData、在室者間同期・同期変数最小化、外部連携なし）を常に満たすようプロンプトテンプレートに明記して作業させる。[1][2]

## Unity プロジェクト設定
- テンプレートは VCC 由来の SDK3 Worlds プロジェクトを採用し、UdonSharp を導入後にスクリプト定義シンボルや.NET互換設定を既定に合わせて固定する（外部連携コードは入れない）。[2][1]
- プラットフォーム設定は PC/Quest を切替運用とし、軽量化（焼き込みライト、共有マテリアル、テクスチャ解像度上限、ミップ）とFPS目標・サイズ目標の達成をビルド前提条件にする。[1][2]

## パッケージと依存
- 必須パッケージは SDK3 Worlds、UdonSharp、および VCC が生成する最小集合に限定し、外部API/DBや追加ネットワーク依存を持つパッケージは採用しない。[2][1]
- 設問・重み・縮約投影・要約テンプレは ScriptableObject で外部化し、ビルドレス調整を可能とする（保守性要件に準拠）。[1][2]

## 開発フロー
- ブランチ戦略は main（安定）/ develop（統合）/ feature/*（機能単位）を採用し、Claude Code は feature ブランチで実装し PR を作成、設計への整合（FR/NFR/コンポーネント責務）をPRテンプレで自己点検する。[2][1]
- 実装は「イベント駆動（回答確定・入退室・公開ON/OFF）での増分再計算」「公開は6軸縮約データのみ同期」「上位3件リスト提示」「1on1導線」を満たす単体・結合テストをローカルで実行する。[1][2]

## ビルドとテスト
- ローカル検証はエディタ再生・複窓での同期挙動・入退室イベント・公開ON/OFFの動作と、PerfGuard の1フレーム上限Kによる負荷安定性を確認する。[2][1]
- ビルドは PC と Quest の双方で行い、「PC≥72FPS/Quest≥60FPS、PC<200MB/Quest<100MB、全再計算PC≤5秒・Quest≤10秒」を目標としてリグレッション確認を行う。[1][2]

## 監視とプロファイル
- プロファイルはフレームタイム・GC・CPUジョブ負荷を中心に、在室人数・公開者数・再計算頻度を指標化し、PerfGuard のK値と増分アルゴリズムで最適化する。[2][1]
- 計算対象を「在室公開者のみ」「6軸縮約」で限定し、全再計算は入退室や回答バッチ更新時に限る方針を徹底する。[1][2]

## セキュリティ・プライバシー
- 生の回答値や30軸ベクトルは公開せず、在室同意時の6軸縮約・要約・タグのみを同期配布し、公開OFFで即時クリアする挙動を必須要件とする。[2][1]
- PlayerData は自分のデータのみ保存・復元し、他者の PlayerData 書込は禁止し、データ未整合時は公開を自動OFFして保護する。[1][2]

## Claude Code の運用規約
- Claude Code が生成・修正するコードは、設計の責務境界（例：VectorBuilderは112→30軸算出、PublicProfilePublisherは30→6軸縮約と同期）を越境しないようプロンプトで拘束する。[2][1]
- 同期変数の追加・型・配列長の変更は「最小限・低頻度・検証必須」をルール化し、Late-joiner と負荷への影響をレビュー項目に含める。[1][2]

## ナレッジと文書
- 設計・要求仕様（requirement.md / design.md / architecture.md / devenv.md）は同一リポジトリでバージョン管理し、機能追加は設計→実装→検証→文書更新までを1PRで完結させる。[2][1]
- 変更時は互換破綻がある場合に新キー保存と移行UIを提供する運用に従い、PlayerData キーのライフサイクルを記録する。[1][2]

## 受入と品質ゲート
- 受入条件は「中断・再開・完了・再訪の再現性」「手入力なしの自動推薦と1on1遷移」「公開OFFで露出ゼロ」「性能・サイズ目標達成」を満たすこととし、PRのチェックリスト化を行う。[2][1]
- リスト表示は在室・公開同意者の縮約ベクトルからコサイン類似度で上位3件を提示し、詳細は要約・レーダーで構成されることを必須とする。[1][2]

## 禁止事項
- 外部API/DB連携、確実通知を要する外部サービス連携、画像の永続保存、他者PlayerData書込、長文自由記述UIの導入を禁止する。[2][1]
- 推薦の対象を在室者以外に拡張する実装、または6軸を超える生データ公開を禁止する。[1][2]

## 付記（実務上の注意）
- 回答確定イベントをトリガに、暫定ベクトル更新→6軸縮約→同期配布→上位リスト再計算のイベントチェーンを軽量に維持し、スロットリングとK上限でフレーム安定化を図る。[2][1]
- 1on1個室の枯渇時は短時間待機ダイアログのみとし、長期予約・メッセージ等の非同期機能は実装しない運用を徹底する。[1]